//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAchievementClient {
    list(): Observable<AchievementListViewModel>;
    search(searchTerm: string | undefined): Observable<AchievementListViewModel>;
    users(achievementId: number | undefined): Observable<AchievementUsersViewModel>;
    adminList(includeArchived: boolean | undefined): Observable<AchievementAdminListViewModel>;
    create(command: CreateAchievementCommand): Observable<AchievementAdminViewModel>;
    claimForUser(command: ClaimAchievementForUserCommand): Observable<ClaimAchievementResult>;
    post(achievementCode: string | undefined): Observable<PostAchievementResult>;
    delete(command: DeleteAchievementCommand): Observable<FileResponse>;
    updateAchievement(command: UpdateAchievementCommand): Observable<FileResponse>;
    claimFormCompleted(command: ClaimFormCompletedAchievementCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class AchievementClient implements IAchievementClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    list(): Observable<AchievementListViewModel> {
        let url_ = this.baseUrl + "/api/Achievement/List";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AchievementListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AchievementListViewModel>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<AchievementListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AchievementListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    search(searchTerm: string | undefined): Observable<AchievementListViewModel> {
        let url_ = this.baseUrl + "/api/Achievement/Search?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AchievementListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AchievementListViewModel>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<AchievementListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AchievementListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    users(achievementId: number | undefined): Observable<AchievementUsersViewModel> {
        let url_ = this.baseUrl + "/api/Achievement/Users?";
        if (achievementId === null)
            throw new Error("The parameter 'achievementId' cannot be null.");
        else if (achievementId !== undefined)
            url_ += "achievementId=" + encodeURIComponent("" + achievementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AchievementUsersViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AchievementUsersViewModel>;
        }));
    }

    protected processUsers(response: HttpResponseBase): Observable<AchievementUsersViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AchievementUsersViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    adminList(includeArchived: boolean | undefined): Observable<AchievementAdminListViewModel> {
        let url_ = this.baseUrl + "/api/Achievement/AdminList?";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AchievementAdminListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AchievementAdminListViewModel>;
        }));
    }

    protected processAdminList(response: HttpResponseBase): Observable<AchievementAdminListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AchievementAdminListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateAchievementCommand): Observable<AchievementAdminViewModel> {
        let url_ = this.baseUrl + "/api/Achievement/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AchievementAdminViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AchievementAdminViewModel>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AchievementAdminViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AchievementAdminViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    claimForUser(command: ClaimAchievementForUserCommand): Observable<ClaimAchievementResult> {
        let url_ = this.baseUrl + "/api/Achievement/ClaimForUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaimForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaimForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimAchievementResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimAchievementResult>;
        }));
    }

    protected processClaimForUser(response: HttpResponseBase): Observable<ClaimAchievementResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimAchievementResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    post(achievementCode: string | undefined): Observable<PostAchievementResult> {
        let url_ = this.baseUrl + "/api/Achievement/Post?";
        if (achievementCode === null)
            throw new Error("The parameter 'achievementCode' cannot be null.");
        else if (achievementCode !== undefined)
            url_ += "achievementCode=" + encodeURIComponent("" + achievementCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostAchievementResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostAchievementResult>;
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<PostAchievementResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostAchievementResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(command: DeleteAchievementCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Achievement/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAchievement(command: UpdateAchievementCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Achievement/UpdateAchievement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAchievement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAchievement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateAchievement(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    claimFormCompleted(command: ClaimFormCompletedAchievementCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Achievement/ClaimFormCompleted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaimFormCompleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaimFormCompleted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processClaimFormCompleted(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAdminTestClient {
    admin(): Observable<FileResponse>;
    notAdmin(): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class AdminTestClient implements IAdminTestClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    admin(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/AdminTest/Admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAdmin(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    notAdmin(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/AdminTest/NotAdmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processNotAdmin(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILeaderboardClient {
    get(): Observable<LeaderboardListViewModel>;
    getEligibleUsers(achievementId: number | undefined, filter: LeaderboardFilter | undefined, filterStaff: boolean | undefined): Observable<EligibleUsersViewModel>;
}

@Injectable({
    providedIn: 'root'
})
export class LeaderboardClient implements ILeaderboardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<LeaderboardListViewModel> {
        let url_ = this.baseUrl + "/api/Leaderboard/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LeaderboardListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LeaderboardListViewModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LeaderboardListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaderboardListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEligibleUsers(achievementId: number | undefined, filter: LeaderboardFilter | undefined, filterStaff: boolean | undefined): Observable<EligibleUsersViewModel> {
        let url_ = this.baseUrl + "/api/Leaderboard/GetEligibleUsers?";
        if (achievementId === null)
            throw new Error("The parameter 'achievementId' cannot be null.");
        else if (achievementId !== undefined)
            url_ += "achievementId=" + encodeURIComponent("" + achievementId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (filterStaff === null)
            throw new Error("The parameter 'filterStaff' cannot be null.");
        else if (filterStaff !== undefined)
            url_ += "filterStaff=" + encodeURIComponent("" + filterStaff) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEligibleUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEligibleUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EligibleUsersViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EligibleUsersViewModel>;
        }));
    }

    protected processGetEligibleUsers(response: HttpResponseBase): Observable<EligibleUsersViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EligibleUsersViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface INotificationsClient {
    list(): Observable<NotificationHistoryListViewModel>;
    requestPush(notificationRequest: RequestNotificationCommand): Observable<Unit>;
    updateInstallation(deviceInstallation: UpdateInstallationCommand): Observable<Unit>;
    deleteInstallation(installationId: string): Observable<Unit>;
}

@Injectable({
    providedIn: 'root'
})
export class NotificationsClient implements INotificationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    list(): Observable<NotificationHistoryListViewModel> {
        let url_ = this.baseUrl + "/api/Notifications/List";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationHistoryListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationHistoryListViewModel>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<NotificationHistoryListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationHistoryListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    requestPush(notificationRequest: RequestNotificationCommand): Observable<Unit> {
        let url_ = this.baseUrl + "/api/Notifications/RequestPush";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notificationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestPush(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestPush(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRequestPush(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateInstallation(deviceInstallation: UpdateInstallationCommand): Observable<Unit> {
        let url_ = this.baseUrl + "/api/Notifications/UpdateInstallation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deviceInstallation);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInstallation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInstallation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processUpdateInstallation(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteInstallation(installationId: string): Observable<Unit> {
        let url_ = this.baseUrl + "/api/Notifications/DeleteInstallation/{installationId}";
        if (installationId === undefined || installationId === null)
            throw new Error("The parameter 'installationId' must be defined.");
        url_ = url_.replace("{installationId}", encodeURIComponent("" + installationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInstallation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInstallation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeleteInstallation(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQuizzesClient {
    getAllQuizzes(): Observable<AdminQuizDto[]>;
    addNewQuiz(quiz: AdminQuizDetailsDto): Observable<number>;
    updateQuiz(quiz: AdminQuizDetailsDto): Observable<number>;
    getQuizListForUser(): Observable<QuizDto[]>;
    getQuizDetails(id: number): Observable<QuizDetailsDto>;
    getQuizDetailsForEdit(id: number): Observable<AdminQuizDetailsDto>;
    submitCompletedQuiz(quiz: SubmitUserQuizCommand): Observable<QuizResultDto>;
}

@Injectable({
    providedIn: 'root'
})
export class QuizzesClient implements IQuizzesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllQuizzes(): Observable<AdminQuizDto[]> {
        let url_ = this.baseUrl + "/api/Quizzes/GetAllQuizzes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuizzes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuizzes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminQuizDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminQuizDto[]>;
        }));
    }

    protected processGetAllQuizzes(response: HttpResponseBase): Observable<AdminQuizDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdminQuizDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addNewQuiz(quiz: AdminQuizDetailsDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Quizzes/AddNewQuiz";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(quiz);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewQuiz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewQuiz(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddNewQuiz(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateQuiz(quiz: AdminQuizDetailsDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Quizzes/UpdateQuiz";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(quiz);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuiz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuiz(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdateQuiz(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getQuizListForUser(): Observable<QuizDto[]> {
        let url_ = this.baseUrl + "/api/Quizzes/GetQuizListForUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuizListForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuizListForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuizDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuizDto[]>;
        }));
    }

    protected processGetQuizListForUser(response: HttpResponseBase): Observable<QuizDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuizDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getQuizDetails(id: number): Observable<QuizDetailsDto> {
        let url_ = this.baseUrl + "/api/Quizzes/GetQuizDetails/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuizDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuizDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuizDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuizDetailsDto>;
        }));
    }

    protected processGetQuizDetails(response: HttpResponseBase): Observable<QuizDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuizDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getQuizDetailsForEdit(id: number): Observable<AdminQuizDetailsDto> {
        let url_ = this.baseUrl + "/api/Quizzes/GetQuizDetailsForEdit/edit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuizDetailsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuizDetailsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminQuizDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminQuizDetailsDto>;
        }));
    }

    protected processGetQuizDetailsForEdit(response: HttpResponseBase): Observable<AdminQuizDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminQuizDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    submitCompletedQuiz(quiz: SubmitUserQuizCommand): Observable<QuizResultDto> {
        let url_ = this.baseUrl + "/api/Quizzes/SubmitCompletedQuiz";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(quiz);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitCompletedQuiz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitCompletedQuiz(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuizResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuizResultDto>;
        }));
    }

    protected processSubmitCompletedQuiz(response: HttpResponseBase): Observable<QuizResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuizResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRewardClient {
    getOnboardingRewards(): Observable<RewardListViewModel>;
    list(): Observable<RewardListViewModel>;
    search(searchTerm: string | undefined): Observable<RewardListViewModel>;
    adminList(): Observable<RewardAdminListViewModel>;
    getRecent(query: GetRecentRewardsQuery): Observable<RecentRewardListViewModel>;
    add(addRewardCommand: AddRewardCommand): Observable<number>;
    claimForUser(claimRewardForUserCommand: ClaimRewardForUserCommand): Observable<ClaimRewardResult>;
    claim(rewardCode: string | undefined): Observable<ClaimRewardResult>;
    delete(command: DeleteRewardCommand): Observable<FileResponse>;
    updateReward(command: UpdateRewardCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class RewardClient implements IRewardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getOnboardingRewards(): Observable<RewardListViewModel> {
        let url_ = this.baseUrl + "/api/Reward/GetOnboardingRewards";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOnboardingRewards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOnboardingRewards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RewardListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RewardListViewModel>;
        }));
    }

    protected processGetOnboardingRewards(response: HttpResponseBase): Observable<RewardListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    list(): Observable<RewardListViewModel> {
        let url_ = this.baseUrl + "/api/Reward/List";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RewardListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RewardListViewModel>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<RewardListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    search(searchTerm: string | undefined): Observable<RewardListViewModel> {
        let url_ = this.baseUrl + "/api/Reward/Search?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RewardListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RewardListViewModel>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<RewardListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    adminList(): Observable<RewardAdminListViewModel> {
        let url_ = this.baseUrl + "/api/Reward/AdminList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RewardAdminListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RewardAdminListViewModel>;
        }));
    }

    protected processAdminList(response: HttpResponseBase): Observable<RewardAdminListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardAdminListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRecent(query: GetRecentRewardsQuery): Observable<RecentRewardListViewModel> {
        let url_ = this.baseUrl + "/api/Reward/GetRecent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecentRewardListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecentRewardListViewModel>;
        }));
    }

    protected processGetRecent(response: HttpResponseBase): Observable<RecentRewardListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecentRewardListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    add(addRewardCommand: AddRewardCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Reward/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addRewardCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    claimForUser(claimRewardForUserCommand: ClaimRewardForUserCommand): Observable<ClaimRewardResult> {
        let url_ = this.baseUrl + "/api/Reward/ClaimForUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(claimRewardForUserCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaimForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaimForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimRewardResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimRewardResult>;
        }));
    }

    protected processClaimForUser(response: HttpResponseBase): Observable<ClaimRewardResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimRewardResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    claim(rewardCode: string | undefined): Observable<ClaimRewardResult> {
        let url_ = this.baseUrl + "/api/Reward/Claim?";
        if (rewardCode === null)
            throw new Error("The parameter 'rewardCode' cannot be null.");
        else if (rewardCode !== undefined)
            url_ += "rewardCode=" + encodeURIComponent("" + rewardCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimRewardResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimRewardResult>;
        }));
    }

    protected processClaim(response: HttpResponseBase): Observable<ClaimRewardResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimRewardResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(command: DeleteRewardCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Reward/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateReward(command: UpdateRewardCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Reward/UpdateReward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReward(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateReward(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISeedClient {
    seedData(): Observable<FileResponse>;
    seedV2Data(): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class SeedClient implements ISeedClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    seedData(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Seed/SeedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeedData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSeedData(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    seedV2Data(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Seed/SeedV2Data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeedV2Data(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeedV2Data(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSeedV2Data(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISkillClient {
    get(): Observable<SkillListViewModel>;
    getAdmin(): Observable<AdminSkill[]>;
    upsertSkill(command: UpsertSkillCommand): Observable<FileResponse>;
    deleteSkill(command: DeleteSkillCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class SkillClient implements ISkillClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<SkillListViewModel> {
        let url_ = this.baseUrl + "/api/Skill/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SkillListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SkillListViewModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SkillListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkillListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAdmin(): Observable<AdminSkill[]> {
        let url_ = this.baseUrl + "/api/Skill/GetAdmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminSkill[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminSkill[]>;
        }));
    }

    protected processGetAdmin(response: HttpResponseBase): Observable<AdminSkill[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdminSkill.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upsertSkill(command: UpsertSkillCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Skill/UpsertSkill";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsertSkill(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsertSkill(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpsertSkill(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteSkill(command: DeleteSkillCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Skill/DeleteSkill";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkill(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkill(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteSkill(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IStaffClient {
    get(): Observable<StaffListViewModel>;
    getStaffMemberProfile(id: number | undefined): Observable<StaffDto>;
    getStaffMemberByEmail(email: string | undefined): Observable<StaffDto>;
    upsertStaffMemberProfile(staffMember: UpsertStaffMemberProfileCommand): Observable<StaffDto>;
    uploadStaffMemberProfilePicture(id: number | undefined, file: FileParameter | null | undefined): Observable<string>;
    deleteStaffMemberProfile(staffMember: DeleteStaffMemberProfileCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class StaffClient implements IStaffClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<StaffListViewModel> {
        let url_ = this.baseUrl + "/api/Staff/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffListViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffListViewModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StaffListViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffListViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStaffMemberProfile(id: number | undefined): Observable<StaffDto> {
        let url_ = this.baseUrl + "/api/Staff/GetStaffMemberProfile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffMemberProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffMemberProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDto>;
        }));
    }

    protected processGetStaffMemberProfile(response: HttpResponseBase): Observable<StaffDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStaffMemberByEmail(email: string | undefined): Observable<StaffDto> {
        let url_ = this.baseUrl + "/api/Staff/GetStaffMemberByEmail?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffMemberByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffMemberByEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDto>;
        }));
    }

    protected processGetStaffMemberByEmail(response: HttpResponseBase): Observable<StaffDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upsertStaffMemberProfile(staffMember: UpsertStaffMemberProfileCommand): Observable<StaffDto> {
        let url_ = this.baseUrl + "/api/Staff/UpsertStaffMemberProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(staffMember);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsertStaffMemberProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsertStaffMemberProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDto>;
        }));
    }

    protected processUpsertStaffMemberProfile(response: HttpResponseBase): Observable<StaffDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadStaffMemberProfilePicture(id: number | undefined, file: FileParameter | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Staff/UploadStaffMemberProfilePicture?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadStaffMemberProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadStaffMemberProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadStaffMemberProfilePicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteStaffMemberProfile(staffMember: DeleteStaffMemberProfileCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Staff/DeleteStaffMemberProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(staffMember);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStaffMemberProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStaffMemberProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteStaffMemberProfile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserClient {
    get(): Observable<CurrentUserViewModel>;
    getUser(id: number): Observable<UserViewModel>;
    achievements(userId: number | undefined): Observable<UserAchievementsViewModel>;
    rewards(userId: number | undefined): Observable<UserRewardsViewModel>;
    profileAchievements(userId: number | undefined): Observable<UserAchievementsViewModel>;
    uploadProfilePic(file: FileParameter | null | undefined): Observable<ProfilePicResponseDto>;
    myRoles(): Observable<string[]>;
    register(): Observable<FileResponse>;
    upsertUserSocialMediaId(command: UpsertUserSocialMediaId): Observable<number>;
    deleteMyProfile(): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UserClient implements IUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<CurrentUserViewModel> {
        let url_ = this.baseUrl + "/api/User/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentUserViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentUserViewModel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CurrentUserViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUserViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUser(id: number): Observable<UserViewModel> {
        let url_ = this.baseUrl + "/api/User/GetUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserViewModel>;
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    achievements(userId: number | undefined): Observable<UserAchievementsViewModel> {
        let url_ = this.baseUrl + "/api/User/Achievements?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAchievements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAchievements(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAchievementsViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAchievementsViewModel>;
        }));
    }

    protected processAchievements(response: HttpResponseBase): Observable<UserAchievementsViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAchievementsViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    rewards(userId: number | undefined): Observable<UserRewardsViewModel> {
        let url_ = this.baseUrl + "/api/User/Rewards?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRewards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRewards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRewardsViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRewardsViewModel>;
        }));
    }

    protected processRewards(response: HttpResponseBase): Observable<UserRewardsViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRewardsViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    profileAchievements(userId: number | undefined): Observable<UserAchievementsViewModel> {
        let url_ = this.baseUrl + "/api/User/ProfileAchievements?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfileAchievements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfileAchievements(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAchievementsViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAchievementsViewModel>;
        }));
    }

    protected processProfileAchievements(response: HttpResponseBase): Observable<UserAchievementsViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAchievementsViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadProfilePic(file: FileParameter | null | undefined): Observable<ProfilePicResponseDto> {
        let url_ = this.baseUrl + "/api/User/UploadProfilePic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadProfilePic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadProfilePic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfilePicResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfilePicResponseDto>;
        }));
    }

    protected processUploadProfilePic(response: HttpResponseBase): Observable<ProfilePicResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfilePicResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    myRoles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/User/MyRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMyRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMyRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processMyRoles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    register(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/User/Register";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upsertUserSocialMediaId(command: UpsertUserSocialMediaId): Observable<number> {
        let url_ = this.baseUrl + "/api/User/UpsertUserSocialMediaId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsertUserSocialMediaId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsertUserSocialMediaId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpsertUserSocialMediaId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMyProfile(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/User/DeleteMyProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMyProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMyProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteMyProfile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AchievementListViewModel implements IAchievementListViewModel {
    achievements?: AchievementDto[];

    constructor(data?: IAchievementListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["achievements"])) {
                this.achievements = [] as any;
                for (let item of _data["achievements"])
                    this.achievements!.push(AchievementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AchievementListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AchievementListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.achievements)) {
            data["achievements"] = [];
            for (let item of this.achievements)
                data["achievements"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAchievementListViewModel {
    achievements?: AchievementDto[];
}

export class AchievementDto implements IAchievementDto {
    id?: number;
    name?: string;
    value?: number;
    type?: AchievementType;

    constructor(data?: IAchievementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): AchievementDto {
        data = typeof data === 'object' ? data : {};
        let result = new AchievementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["type"] = this.type;
        return data;
    }
}

export interface IAchievementDto {
    id?: number;
    name?: string;
    value?: number;
    type?: AchievementType;
}

export enum AchievementType {
    Scanned = 0,
    Attended = 1,
    Completed = 2,
    Linked = 3,
}

export class AchievementUsersViewModel implements IAchievementUsersViewModel {
    achievementName?: string;
    users?: AchievementUserDto[];

    constructor(data?: IAchievementUsersViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.achievementName = _data["achievementName"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(AchievementUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AchievementUsersViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AchievementUsersViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["achievementName"] = this.achievementName;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAchievementUsersViewModel {
    achievementName?: string;
    users?: AchievementUserDto[];
}

export class AchievementUserDto implements IAchievementUserDto {
    userId?: number;
    userName?: string;
    userEmail?: string;
    awardedAtUtc?: Date;

    constructor(data?: IAchievementUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userEmail = _data["userEmail"];
            this.awardedAtUtc = _data["awardedAtUtc"] ? new Date(_data["awardedAtUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AchievementUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AchievementUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userEmail"] = this.userEmail;
        data["awardedAtUtc"] = this.awardedAtUtc ? this.awardedAtUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAchievementUserDto {
    userId?: number;
    userName?: string;
    userEmail?: string;
    awardedAtUtc?: Date;
}

export class AchievementAdminListViewModel implements IAchievementAdminListViewModel {
    achievements?: AchievementAdminViewModel[];

    constructor(data?: IAchievementAdminListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["achievements"])) {
                this.achievements = [] as any;
                for (let item of _data["achievements"])
                    this.achievements!.push(AchievementAdminViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AchievementAdminListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AchievementAdminListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.achievements)) {
            data["achievements"] = [];
            for (let item of this.achievements)
                data["achievements"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAchievementAdminListViewModel {
    achievements?: AchievementAdminViewModel[];
}

export class AchievementAdminViewModel implements IAchievementAdminViewModel {
    id?: number;
    name?: string;
    value?: number;
    code?: string;
    type?: AchievementType;
    isArchived?: boolean | undefined;
    isMultiScanEnabled?: boolean | undefined;
    integrationId?: string | undefined;

    constructor(data?: IAchievementAdminViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.code = _data["code"];
            this.type = _data["type"];
            this.isArchived = _data["isArchived"];
            this.isMultiScanEnabled = _data["isMultiScanEnabled"];
            this.integrationId = _data["integrationId"];
        }
    }

    static fromJS(data: any): AchievementAdminViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AchievementAdminViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["code"] = this.code;
        data["type"] = this.type;
        data["isArchived"] = this.isArchived;
        data["isMultiScanEnabled"] = this.isMultiScanEnabled;
        data["integrationId"] = this.integrationId;
        return data;
    }
}

export interface IAchievementAdminViewModel {
    id?: number;
    name?: string;
    value?: number;
    code?: string;
    type?: AchievementType;
    isArchived?: boolean | undefined;
    isMultiScanEnabled?: boolean | undefined;
    integrationId?: string | undefined;
}

export class CreateAchievementCommand implements ICreateAchievementCommand {
    name?: string;
    value?: number;
    type?: AchievementType;
    isMultiscanEnabled?: boolean;

    constructor(data?: ICreateAchievementCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.isMultiscanEnabled = _data["isMultiscanEnabled"];
        }
    }

    static fromJS(data: any): CreateAchievementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAchievementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        data["type"] = this.type;
        data["isMultiscanEnabled"] = this.isMultiscanEnabled;
        return data;
    }
}

export interface ICreateAchievementCommand {
    name?: string;
    value?: number;
    type?: AchievementType;
    isMultiscanEnabled?: boolean;
}

export class ClaimAchievementResult implements IClaimAchievementResult {
    status?: ClaimAchievementStatus;

    constructor(data?: IClaimAchievementResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ClaimAchievementResult {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimAchievementResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IClaimAchievementResult {
    status?: ClaimAchievementStatus;
}

export enum ClaimAchievementStatus {
    Claimed = 0,
    NotFound = 1,
    Duplicate = 2,
    NotEnoughPoints = 3,
    Error = 4,
}

export class ClaimAchievementForUserCommand implements IClaimAchievementForUserCommand {
    userId?: number;
    code?: string;

    constructor(data?: IClaimAchievementForUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ClaimAchievementForUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimAchievementForUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["code"] = this.code;
        return data;
    }
}

export interface IClaimAchievementForUserCommand {
    userId?: number;
    code?: string;
}

export class PostAchievementResult implements IPostAchievementResult {
    viewModel?: AchievementDto | undefined;
    status?: AchievementStatus;

    constructor(data?: IPostAchievementResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.viewModel = _data["viewModel"] ? AchievementDto.fromJS(_data["viewModel"]) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): PostAchievementResult {
        data = typeof data === 'object' ? data : {};
        let result = new PostAchievementResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viewModel"] = this.viewModel ? this.viewModel.toJSON() : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

export interface IPostAchievementResult {
    viewModel?: AchievementDto | undefined;
    status?: AchievementStatus;
}

export enum AchievementStatus {
    Added = 0,
    NotFound = 1,
    Duplicate = 2,
    Error = 3,
}

export class DeleteAchievementCommand implements IDeleteAchievementCommand {
    id?: number;

    constructor(data?: IDeleteAchievementCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteAchievementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteAchievementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteAchievementCommand {
    id?: number;
}

export class UpdateAchievementCommand implements IUpdateAchievementCommand {
    id?: number;
    value?: number;
    type?: AchievementType;
    isMultiscanEnabled?: boolean;

    constructor(data?: IUpdateAchievementCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.isMultiscanEnabled = _data["isMultiscanEnabled"];
        }
    }

    static fromJS(data: any): UpdateAchievementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAchievementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["isMultiscanEnabled"] = this.isMultiscanEnabled;
        return data;
    }
}

export interface IUpdateAchievementCommand {
    id?: number;
    value?: number;
    type?: AchievementType;
    isMultiscanEnabled?: boolean;
}

export class ClaimFormCompletedAchievementCommand implements IClaimFormCompletedAchievementCommand {
    email?: string;
    integrationId?: string;

    constructor(data?: IClaimFormCompletedAchievementCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.integrationId = _data["integrationId"];
        }
    }

    static fromJS(data: any): ClaimFormCompletedAchievementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimFormCompletedAchievementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["integrationId"] = this.integrationId;
        return data;
    }
}

export interface IClaimFormCompletedAchievementCommand {
    email?: string;
    integrationId?: string;
}

export class LeaderboardListViewModel implements ILeaderboardListViewModel {
    users?: LeaderboardUserDto[];

    constructor(data?: ILeaderboardListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(LeaderboardUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LeaderboardListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LeaderboardListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILeaderboardListViewModel {
    users?: LeaderboardUserDto[];
}

export class LeaderboardUserDto implements ILeaderboardUserDto {
    rank?: number;
    userId?: number;
    name?: string | undefined;
    email?: string | undefined;
    profilePic?: string | undefined;
    totalPoints?: number;
    pointsClaimed?: number;
    pointsToday?: number;
    pointsThisWeek?: number;
    pointsThisMonth?: number;
    pointsThisYear?: number;
    balance?: number;

    constructor(data?: ILeaderboardUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rank = _data["rank"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.profilePic = _data["profilePic"];
            this.totalPoints = _data["totalPoints"];
            this.pointsClaimed = _data["pointsClaimed"];
            this.pointsToday = _data["pointsToday"];
            this.pointsThisWeek = _data["pointsThisWeek"];
            this.pointsThisMonth = _data["pointsThisMonth"];
            this.pointsThisYear = _data["pointsThisYear"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): LeaderboardUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaderboardUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rank"] = this.rank;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["profilePic"] = this.profilePic;
        data["totalPoints"] = this.totalPoints;
        data["pointsClaimed"] = this.pointsClaimed;
        data["pointsToday"] = this.pointsToday;
        data["pointsThisWeek"] = this.pointsThisWeek;
        data["pointsThisMonth"] = this.pointsThisMonth;
        data["pointsThisYear"] = this.pointsThisYear;
        data["balance"] = this.balance;
        return data;
    }
}

export interface ILeaderboardUserDto {
    rank?: number;
    userId?: number;
    name?: string | undefined;
    email?: string | undefined;
    profilePic?: string | undefined;
    totalPoints?: number;
    pointsClaimed?: number;
    pointsToday?: number;
    pointsThisWeek?: number;
    pointsThisMonth?: number;
    pointsThisYear?: number;
    balance?: number;
}

export class EligibleUsersViewModel implements IEligibleUsersViewModel {
    achievementId?: number;
    achievementName?: string;
    eligibleUsers?: EligibleUserDto[];

    constructor(data?: IEligibleUsersViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.achievementId = _data["achievementId"];
            this.achievementName = _data["achievementName"];
            if (Array.isArray(_data["eligibleUsers"])) {
                this.eligibleUsers = [] as any;
                for (let item of _data["eligibleUsers"])
                    this.eligibleUsers!.push(EligibleUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EligibleUsersViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new EligibleUsersViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["achievementId"] = this.achievementId;
        data["achievementName"] = this.achievementName;
        if (Array.isArray(this.eligibleUsers)) {
            data["eligibleUsers"] = [];
            for (let item of this.eligibleUsers)
                data["eligibleUsers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEligibleUsersViewModel {
    achievementId?: number;
    achievementName?: string;
    eligibleUsers?: EligibleUserDto[];
}

export class EligibleUserDto implements IEligibleUserDto {
    userId?: number | undefined;
    name?: string | undefined;
    email?: string | undefined;
    totalPoints?: number;
    pointsClaimed?: number;
    pointsToday?: number;
    pointsThisWeek?: number;
    pointsThisMonth?: number;
    pointsThisYear?: number;
    balance?: number;

    constructor(data?: IEligibleUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.totalPoints = _data["totalPoints"];
            this.pointsClaimed = _data["pointsClaimed"];
            this.pointsToday = _data["pointsToday"];
            this.pointsThisWeek = _data["pointsThisWeek"];
            this.pointsThisMonth = _data["pointsThisMonth"];
            this.pointsThisYear = _data["pointsThisYear"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): EligibleUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new EligibleUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["totalPoints"] = this.totalPoints;
        data["pointsClaimed"] = this.pointsClaimed;
        data["pointsToday"] = this.pointsToday;
        data["pointsThisWeek"] = this.pointsThisWeek;
        data["pointsThisMonth"] = this.pointsThisMonth;
        data["pointsThisYear"] = this.pointsThisYear;
        data["balance"] = this.balance;
        return data;
    }
}

export interface IEligibleUserDto {
    userId?: number | undefined;
    name?: string | undefined;
    email?: string | undefined;
    totalPoints?: number;
    pointsClaimed?: number;
    pointsToday?: number;
    pointsThisWeek?: number;
    pointsThisMonth?: number;
    pointsThisYear?: number;
    balance?: number;
}

export enum LeaderboardFilter {
    ThisMonth = 0,
    ThisYear = 1,
    ThisWeek = 2,
    Today = 3,
    Forever = 4,
}

export class NotificationHistoryListViewModel implements INotificationHistoryListViewModel {
    list?: NotificationHistoryDto[];

    constructor(data?: INotificationHistoryListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(NotificationHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationHistoryListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationHistoryListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        return data;
    }
}

export interface INotificationHistoryListViewModel {
    list?: NotificationHistoryDto[];
}

export class NotificationHistoryDto implements INotificationHistoryDto {
    message?: string;
    createdDate?: Date;
    emailAddress?: string;

    constructor(data?: INotificationHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): NotificationHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface INotificationHistoryDto {
    message?: string;
    createdDate?: Date;
    emailAddress?: string;
}

/** Represents a void type, since Void is not a valid return type in C#. */
export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Represents a void type, since Void is not a valid return type in C#. */
export interface IUnit {
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RequestNotificationCommand implements IRequestNotificationCommand {
    text?: string;
    action?: string;
    tags?: string[];
    silent?: boolean;

    constructor(data?: IRequestNotificationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.action = _data["action"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.silent = _data["silent"];
        }
    }

    static fromJS(data: any): RequestNotificationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RequestNotificationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["action"] = this.action;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["silent"] = this.silent;
        return data;
    }
}

export interface IRequestNotificationCommand {
    text?: string;
    action?: string;
    tags?: string[];
    silent?: boolean;
}

export class UpdateInstallationCommand implements IUpdateInstallationCommand {
    installationId?: string;
    platform?: string;
    pushChannel?: string;
    tags?: string[];

    constructor(data?: IUpdateInstallationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.installationId = _data["installationId"];
            this.platform = _data["platform"];
            this.pushChannel = _data["pushChannel"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateInstallationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInstallationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["installationId"] = this.installationId;
        data["platform"] = this.platform;
        data["pushChannel"] = this.pushChannel;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IUpdateInstallationCommand {
    installationId?: string;
    platform?: string;
    pushChannel?: string;
    tags?: string[];
}

export class AdminQuizDto implements IAdminQuizDto {
    id?: number;
    title?: string;
    description?: string;
    points?: number;
    dateCreated?: Date;

    constructor(data?: IAdminQuizDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.points = _data["points"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AdminQuizDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminQuizDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["points"] = this.points;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAdminQuizDto {
    id?: number;
    title?: string;
    description?: string;
    points?: number;
    dateCreated?: Date;
}

export class AdminQuizDetailsDto implements IAdminQuizDetailsDto {
    quizId?: number;
    title?: string;
    description?: string;
    points?: number;
    icon?: Icons;
    isArchived?: boolean;
    questions?: AdminQuizQuestionDto[];

    constructor(data?: IAdminQuizDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quizId = _data["quizId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.points = _data["points"];
            this.icon = _data["icon"];
            this.isArchived = _data["isArchived"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(AdminQuizQuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminQuizDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminQuizDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizId"] = this.quizId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["points"] = this.points;
        data["icon"] = this.icon;
        data["isArchived"] = this.isArchived;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAdminQuizDetailsDto {
    quizId?: number;
    title?: string;
    description?: string;
    points?: number;
    icon?: Icons;
    isArchived?: boolean;
    questions?: AdminQuizQuestionDto[];
}

export enum Icons {
    Twitter = 0,
    Github = 1,
    LinkedinIn = 2,
    Instagram = 3,
    Linkedin = 4,
    TwitterSquare = 5,
    GithubSquare = 6,
    Youtube = 7,
    Microsoft = 8,
    Facebook = 9,
    Camera = 10,
    Certificate = 11,
    Lightning = 12,
    Mortarboard = 13,
    Handshake = 14,
    Lightbulb = 15,
    More = 16,
    People = 17,
    Puzzle = 18,
    Trophy = 19,
    Alert = 20,
    RightChevron = 21,
    LeftChevron = 22,
    ArrowExportUp = 23,
    SignOut = 24,
    Person = 25,
    PersonAdd = 26,
    Cake = 27,
    CalendarEmpty = 28,
    CalendarCheck = 29,
    Help = 30,
    Chat = 31,
    Gift = 32,
    Home = 33,
    Info = 34,
    QRCode = 35,
    Angular = 36,
    Ribbon = 37,
}

export class AdminQuizQuestionDto implements IAdminQuizQuestionDto {
    questionId?: number;
    text?: string;
    answers?: AdminQuestionAnswerDto[];

    constructor(data?: IAdminQuizQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.text = _data["text"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AdminQuestionAnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminQuizQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminQuizQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["text"] = this.text;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAdminQuizQuestionDto {
    questionId?: number;
    text?: string;
    answers?: AdminQuestionAnswerDto[];
}

export class AdminQuestionAnswerDto implements IAdminQuestionAnswerDto {
    questionAnswerId?: number;
    text?: string;
    isCorrect?: boolean;

    constructor(data?: IAdminQuestionAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionAnswerId = _data["questionAnswerId"];
            this.text = _data["text"];
            this.isCorrect = _data["isCorrect"];
        }
    }

    static fromJS(data: any): AdminQuestionAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminQuestionAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionAnswerId"] = this.questionAnswerId;
        data["text"] = this.text;
        data["isCorrect"] = this.isCorrect;
        return data;
    }
}

export interface IAdminQuestionAnswerDto {
    questionAnswerId?: number;
    text?: string;
    isCorrect?: boolean;
}

export class QuizDto implements IQuizDto {
    id?: number;
    title?: string;
    description?: string;
    passed?: boolean;
    icon?: Icons;

    constructor(data?: IQuizDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.passed = _data["passed"];
            this.icon = _data["icon"];
        }
    }

    static fromJS(data: any): QuizDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["passed"] = this.passed;
        data["icon"] = this.icon;
        return data;
    }
}

export interface IQuizDto {
    id?: number;
    title?: string;
    description?: string;
    passed?: boolean;
    icon?: Icons;
}

export class QuizDetailsDto implements IQuizDetailsDto {
    quizId?: number;
    title?: string;
    description?: string;
    points?: number;
    icon?: Icons;
    questions?: QuizQuestionDto[];

    constructor(data?: IQuizDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quizId = _data["quizId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.points = _data["points"];
            this.icon = _data["icon"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuizQuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizId"] = this.quizId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["points"] = this.points;
        data["icon"] = this.icon;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuizDetailsDto {
    quizId?: number;
    title?: string;
    description?: string;
    points?: number;
    icon?: Icons;
    questions?: QuizQuestionDto[];
}

export class QuizQuestionDto implements IQuizQuestionDto {
    questionId?: number;
    text?: string;
    answers?: QuestionAnswerDto[];

    constructor(data?: IQuizQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.text = _data["text"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(QuestionAnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuizQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["text"] = this.text;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuizQuestionDto {
    questionId?: number;
    text?: string;
    answers?: QuestionAnswerDto[];
}

export class QuestionAnswerDto implements IQuestionAnswerDto {
    questionAnswerId?: number;
    text?: string;
    isCorrect?: boolean;

    constructor(data?: IQuestionAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionAnswerId = _data["questionAnswerId"];
            this.text = _data["text"];
            this.isCorrect = _data["isCorrect"];
        }
    }

    static fromJS(data: any): QuestionAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionAnswerId"] = this.questionAnswerId;
        data["text"] = this.text;
        data["isCorrect"] = this.isCorrect;
        return data;
    }
}

export interface IQuestionAnswerDto {
    questionAnswerId?: number;
    text?: string;
    isCorrect?: boolean;
}

export class QuizResultDto implements IQuizResultDto {
    quizId?: number;
    passed?: boolean;
    results?: QuestionResultDto[];
    points?: number;

    constructor(data?: IQuizResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quizId = _data["quizId"];
            this.passed = _data["passed"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(QuestionResultDto.fromJS(item));
            }
            this.points = _data["points"];
        }
    }

    static fromJS(data: any): QuizResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizId"] = this.quizId;
        data["passed"] = this.passed;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["points"] = this.points;
        return data;
    }
}

export interface IQuizResultDto {
    quizId?: number;
    passed?: boolean;
    results?: QuestionResultDto[];
    points?: number;
}

export class QuestionResultDto implements IQuestionResultDto {
    questionId?: number;
    correct?: boolean;

    constructor(data?: IQuestionResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.correct = _data["correct"];
        }
    }

    static fromJS(data: any): QuestionResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["correct"] = this.correct;
        return data;
    }
}

export interface IQuestionResultDto {
    questionId?: number;
    correct?: boolean;
}

export class SubmitUserQuizCommand implements ISubmitUserQuizCommand {
    quizId?: number;
    answers?: QuizAnswerDto[];

    constructor(data?: ISubmitUserQuizCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quizId = _data["quizId"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(QuizAnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitUserQuizCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitUserQuizCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quizId"] = this.quizId;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubmitUserQuizCommand {
    quizId?: number;
    answers?: QuizAnswerDto[];
}

export class QuizAnswerDto implements IQuizAnswerDto {
    questionId?: number;
    selectedAnswerId?: number;

    constructor(data?: IQuizAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.selectedAnswerId = _data["selectedAnswerId"];
        }
    }

    static fromJS(data: any): QuizAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["selectedAnswerId"] = this.selectedAnswerId;
        return data;
    }
}

export interface IQuizAnswerDto {
    questionId?: number;
    selectedAnswerId?: number;
}

export class RewardListViewModel implements IRewardListViewModel {
    rewards?: RewardViewModel[];

    constructor(data?: IRewardListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rewards"])) {
                this.rewards = [] as any;
                for (let item of _data["rewards"])
                    this.rewards!.push(RewardViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RewardListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RewardListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rewards)) {
            data["rewards"] = [];
            for (let item of this.rewards)
                data["rewards"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRewardListViewModel {
    rewards?: RewardViewModel[];
}

export class RewardViewModel implements IRewardViewModel {
    id?: number;
    name?: string;
    cost?: number;
    imageUri?: string | undefined;
    rewardType?: RewardType;

    constructor(data?: IRewardViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.cost = _data["cost"];
            this.imageUri = _data["imageUri"];
            this.rewardType = _data["rewardType"];
        }
    }

    static fromJS(data: any): RewardViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RewardViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["cost"] = this.cost;
        data["imageUri"] = this.imageUri;
        data["rewardType"] = this.rewardType;
        return data;
    }
}

export interface IRewardViewModel {
    id?: number;
    name?: string;
    cost?: number;
    imageUri?: string | undefined;
    rewardType?: RewardType;
}

export enum RewardType {
    Physical = 0,
    Digital = 1,
}

export class RewardAdminListViewModel implements IRewardAdminListViewModel {
    rewards?: RewardAdminViewModel[];

    constructor(data?: IRewardAdminListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rewards"])) {
                this.rewards = [] as any;
                for (let item of _data["rewards"])
                    this.rewards!.push(RewardAdminViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RewardAdminListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RewardAdminListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rewards)) {
            data["rewards"] = [];
            for (let item of this.rewards)
                data["rewards"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRewardAdminListViewModel {
    rewards?: RewardAdminViewModel[];
}

export class RewardAdminViewModel implements IRewardAdminViewModel {
    id?: number;
    name?: string;
    cost?: number;
    code?: string;
    imageUri?: string | undefined;

    constructor(data?: IRewardAdminViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.cost = _data["cost"];
            this.code = _data["code"];
            this.imageUri = _data["imageUri"];
        }
    }

    static fromJS(data: any): RewardAdminViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RewardAdminViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["cost"] = this.cost;
        data["code"] = this.code;
        data["imageUri"] = this.imageUri;
        return data;
    }
}

export interface IRewardAdminViewModel {
    id?: number;
    name?: string;
    cost?: number;
    code?: string;
    imageUri?: string | undefined;
}

export class RecentRewardListViewModel implements IRecentRewardListViewModel {
    rewards?: RecentRewardViewModel[];

    constructor(data?: IRecentRewardListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rewards"])) {
                this.rewards = [] as any;
                for (let item of _data["rewards"])
                    this.rewards!.push(RecentRewardViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecentRewardListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RecentRewardListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rewards)) {
            data["rewards"] = [];
            for (let item of this.rewards)
                data["rewards"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRecentRewardListViewModel {
    rewards?: RecentRewardViewModel[];
}

export class RecentRewardViewModel implements IRecentRewardViewModel {
    rewardName?: string;
    rewardCost?: number;
    awardedTo?: string;
    awardedAt?: Date;

    constructor(data?: IRecentRewardViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rewardName = _data["rewardName"];
            this.rewardCost = _data["rewardCost"];
            this.awardedTo = _data["awardedTo"];
            this.awardedAt = _data["awardedAt"] ? new Date(_data["awardedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentRewardViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RecentRewardViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rewardName"] = this.rewardName;
        data["rewardCost"] = this.rewardCost;
        data["awardedTo"] = this.awardedTo;
        data["awardedAt"] = this.awardedAt ? this.awardedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRecentRewardViewModel {
    rewardName?: string;
    rewardCost?: number;
    awardedTo?: string;
    awardedAt?: Date;
}

export class GetRecentRewardsQuery implements IGetRecentRewardsQuery {
    since?: Date | undefined;

    constructor(data?: IGetRecentRewardsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.since = _data["since"] ? new Date(_data["since"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRecentRewardsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentRewardsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["since"] = this.since ? this.since.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGetRecentRewardsQuery {
    since?: Date | undefined;
}

export class AddRewardCommand implements IAddRewardCommand {
    id?: number;
    name?: string;
    cost?: number;
    imageUri?: string;
    rewardType?: RewardType;
    imageBytesInBase64?: string;
    imageFileName?: string;

    constructor(data?: IAddRewardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.cost = _data["cost"];
            this.imageUri = _data["imageUri"];
            this.rewardType = _data["rewardType"];
            this.imageBytesInBase64 = _data["imageBytesInBase64"];
            this.imageFileName = _data["imageFileName"];
        }
    }

    static fromJS(data: any): AddRewardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddRewardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["cost"] = this.cost;
        data["imageUri"] = this.imageUri;
        data["rewardType"] = this.rewardType;
        data["imageBytesInBase64"] = this.imageBytesInBase64;
        data["imageFileName"] = this.imageFileName;
        return data;
    }
}

export interface IAddRewardCommand {
    id?: number;
    name?: string;
    cost?: number;
    imageUri?: string;
    rewardType?: RewardType;
    imageBytesInBase64?: string;
    imageFileName?: string;
}

export class ClaimRewardResult implements IClaimRewardResult {
    viewModel?: RewardViewModel | undefined;
    status?: RewardStatus;

    constructor(data?: IClaimRewardResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.viewModel = _data["viewModel"] ? RewardViewModel.fromJS(_data["viewModel"]) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ClaimRewardResult {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimRewardResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viewModel"] = this.viewModel ? this.viewModel.toJSON() : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

export interface IClaimRewardResult {
    viewModel?: RewardViewModel | undefined;
    status?: RewardStatus;
}

export enum RewardStatus {
    Claimed = 0,
    NotFound = 1,
    Duplicate = 2,
    NotEnoughPoints = 3,
    Error = 4,
}

export class ClaimRewardForUserCommand implements IClaimRewardForUserCommand {
    userId?: number;
    code?: string;

    constructor(data?: IClaimRewardForUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ClaimRewardForUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimRewardForUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["code"] = this.code;
        return data;
    }
}

export interface IClaimRewardForUserCommand {
    userId?: number;
    code?: string;
}

export class DeleteRewardCommand implements IDeleteRewardCommand {
    id?: number;

    constructor(data?: IDeleteRewardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteRewardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRewardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteRewardCommand {
    id?: number;
}

export class UpdateRewardCommand implements IUpdateRewardCommand {
    id?: number;
    cost?: number;
    rewardName?: string | undefined;
    imageFilename?: string | undefined;
    imageBytesInBase64?: string | undefined;
    isOnboardingReward?: boolean | undefined;

    constructor(data?: IUpdateRewardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cost = _data["cost"];
            this.rewardName = _data["rewardName"];
            this.imageFilename = _data["imageFilename"];
            this.imageBytesInBase64 = _data["imageBytesInBase64"];
            this.isOnboardingReward = _data["isOnboardingReward"];
        }
    }

    static fromJS(data: any): UpdateRewardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRewardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cost"] = this.cost;
        data["rewardName"] = this.rewardName;
        data["imageFilename"] = this.imageFilename;
        data["imageBytesInBase64"] = this.imageBytesInBase64;
        data["isOnboardingReward"] = this.isOnboardingReward;
        return data;
    }
}

export interface IUpdateRewardCommand {
    id?: number;
    cost?: number;
    rewardName?: string | undefined;
    imageFilename?: string | undefined;
    imageBytesInBase64?: string | undefined;
    isOnboardingReward?: boolean | undefined;
}

export class SkillListViewModel implements ISkillListViewModel {
    skills?: string[];

    constructor(data?: ISkillListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
        }
    }

    static fromJS(data: any): SkillListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SkillListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        return data;
    }
}

export interface ISkillListViewModel {
    skills?: string[];
}

export class AdminSkill implements IAdminSkill {
    id?: number;
    name?: string;

    constructor(data?: IAdminSkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AdminSkill {
        data = typeof data === 'object' ? data : {};
        let result = new AdminSkill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IAdminSkill {
    id?: number;
    name?: string;
}

export class UpsertSkillCommand implements IUpsertSkillCommand {
    id?: number;
    skill?: string;

    constructor(data?: IUpsertSkillCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.skill = _data["skill"];
        }
    }

    static fromJS(data: any): UpsertSkillCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertSkillCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skill"] = this.skill;
        return data;
    }
}

export interface IUpsertSkillCommand {
    id?: number;
    skill?: string;
}

export class DeleteSkillCommand implements IDeleteSkillCommand {
    id?: number;

    constructor(data?: IDeleteSkillCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteSkillCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteSkillCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteSkillCommand {
    id?: number;
}

export class StaffListViewModel implements IStaffListViewModel {
    staff?: StaffDto[];

    constructor(data?: IStaffListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["staff"])) {
                this.staff = [] as any;
                for (let item of _data["staff"])
                    this.staff!.push(StaffDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StaffListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new StaffListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.staff)) {
            data["staff"] = [];
            for (let item of this.staff)
                data["staff"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStaffListViewModel {
    staff?: StaffDto[];
}

export class StaffDto implements IStaffDto {
    id?: number;
    name?: string | undefined;
    title?: string | undefined;
    email?: string | undefined;
    profile?: string | undefined;
    profilePhoto?: string | undefined;
    isDeleted?: boolean;
    twitterUsername?: string | undefined;
    gitHubUsername?: string | undefined;
    linkedInUrl?: string | undefined;
    isExternal?: boolean;
    staffAchievement?: AchievementDto | undefined;
    scanned?: boolean;
    skills?: StaffSkillDto[];

    constructor(data?: IStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.title = _data["title"];
            this.email = _data["email"];
            this.profile = _data["profile"];
            this.profilePhoto = _data["profilePhoto"];
            this.isDeleted = _data["isDeleted"];
            this.twitterUsername = _data["twitterUsername"];
            this.gitHubUsername = _data["gitHubUsername"];
            this.linkedInUrl = _data["linkedInUrl"];
            this.isExternal = _data["isExternal"];
            this.staffAchievement = _data["staffAchievement"] ? AchievementDto.fromJS(_data["staffAchievement"]) : <any>undefined;
            this.scanned = _data["scanned"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(StaffSkillDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["title"] = this.title;
        data["email"] = this.email;
        data["profile"] = this.profile;
        data["profilePhoto"] = this.profilePhoto;
        data["isDeleted"] = this.isDeleted;
        data["twitterUsername"] = this.twitterUsername;
        data["gitHubUsername"] = this.gitHubUsername;
        data["linkedInUrl"] = this.linkedInUrl;
        data["isExternal"] = this.isExternal;
        data["staffAchievement"] = this.staffAchievement ? this.staffAchievement.toJSON() : <any>undefined;
        data["scanned"] = this.scanned;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStaffDto {
    id?: number;
    name?: string | undefined;
    title?: string | undefined;
    email?: string | undefined;
    profile?: string | undefined;
    profilePhoto?: string | undefined;
    isDeleted?: boolean;
    twitterUsername?: string | undefined;
    gitHubUsername?: string | undefined;
    linkedInUrl?: string | undefined;
    isExternal?: boolean;
    staffAchievement?: AchievementDto | undefined;
    scanned?: boolean;
    skills?: StaffSkillDto[];
}

export class StaffSkillDto implements IStaffSkillDto {
    name?: string;
    level?: SkillLevel;

    constructor(data?: IStaffSkillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): StaffSkillDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffSkillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["level"] = this.level;
        return data;
    }
}

export interface IStaffSkillDto {
    name?: string;
    level?: SkillLevel;
}

export enum SkillLevel {
    Beginner = 0,
    Intermediate = 1,
    Advanced = 2,
}

export class UpsertStaffMemberProfileCommand implements IUpsertStaffMemberProfileCommand {
    id?: number;
    name?: string;
    title?: string;
    email?: string;
    profile?: string;
    twitterUsername?: string;
    gitHubUsername?: string;
    linkedInUrl?: string;
    profilePhoto?: string;
    points?: number;
    skills?: StaffSkillDto[];

    constructor(data?: IUpsertStaffMemberProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.title = _data["title"];
            this.email = _data["email"];
            this.profile = _data["profile"];
            this.twitterUsername = _data["twitterUsername"];
            this.gitHubUsername = _data["gitHubUsername"];
            this.linkedInUrl = _data["linkedInUrl"];
            this.profilePhoto = _data["profilePhoto"];
            this.points = _data["points"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(StaffSkillDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpsertStaffMemberProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertStaffMemberProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["title"] = this.title;
        data["email"] = this.email;
        data["profile"] = this.profile;
        data["twitterUsername"] = this.twitterUsername;
        data["gitHubUsername"] = this.gitHubUsername;
        data["linkedInUrl"] = this.linkedInUrl;
        data["profilePhoto"] = this.profilePhoto;
        data["points"] = this.points;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpsertStaffMemberProfileCommand {
    id?: number;
    name?: string;
    title?: string;
    email?: string;
    profile?: string;
    twitterUsername?: string;
    gitHubUsername?: string;
    linkedInUrl?: string;
    profilePhoto?: string;
    points?: number;
    skills?: StaffSkillDto[];
}

export class DeleteStaffMemberProfileCommand implements IDeleteStaffMemberProfileCommand {
    id?: number;
    name?: string;
    title?: string;
    email?: string;
    profile?: string;
    twitterUsername?: string;

    constructor(data?: IDeleteStaffMemberProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.title = _data["title"];
            this.email = _data["email"];
            this.profile = _data["profile"];
            this.twitterUsername = _data["twitterUsername"];
        }
    }

    static fromJS(data: any): DeleteStaffMemberProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteStaffMemberProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["title"] = this.title;
        data["email"] = this.email;
        data["profile"] = this.profile;
        data["twitterUsername"] = this.twitterUsername;
        return data;
    }
}

export interface IDeleteStaffMemberProfileCommand {
    id?: number;
    name?: string;
    title?: string;
    email?: string;
    profile?: string;
    twitterUsername?: string;
}

export class CurrentUserViewModel implements ICurrentUserViewModel {
    id?: number;
    email?: string;
    fullName?: string;
    profilePic?: string | undefined;
    points?: number;
    balance?: number;
    qrCode?: string | undefined;

    constructor(data?: ICurrentUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.profilePic = _data["profilePic"];
            this.points = _data["points"];
            this.balance = _data["balance"];
            this.qrCode = _data["qrCode"];
        }
    }

    static fromJS(data: any): CurrentUserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["profilePic"] = this.profilePic;
        data["points"] = this.points;
        data["balance"] = this.balance;
        data["qrCode"] = this.qrCode;
        return data;
    }
}

export interface ICurrentUserViewModel {
    id?: number;
    email?: string;
    fullName?: string;
    profilePic?: string | undefined;
    points?: number;
    balance?: number;
    qrCode?: string | undefined;
}

export class UserViewModel implements IUserViewModel {
    id?: number;
    fullName?: string;
    profilePic?: string;
    points?: number;
    balance?: number;
    rewards?: UserRewardDto[];
    achievements?: UserAchievementDto[];

    constructor(data?: IUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.profilePic = _data["profilePic"];
            this.points = _data["points"];
            this.balance = _data["balance"];
            if (Array.isArray(_data["rewards"])) {
                this.rewards = [] as any;
                for (let item of _data["rewards"])
                    this.rewards!.push(UserRewardDto.fromJS(item));
            }
            if (Array.isArray(_data["achievements"])) {
                this.achievements = [] as any;
                for (let item of _data["achievements"])
                    this.achievements!.push(UserAchievementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["profilePic"] = this.profilePic;
        data["points"] = this.points;
        data["balance"] = this.balance;
        if (Array.isArray(this.rewards)) {
            data["rewards"] = [];
            for (let item of this.rewards)
                data["rewards"].push(item.toJSON());
        }
        if (Array.isArray(this.achievements)) {
            data["achievements"] = [];
            for (let item of this.achievements)
                data["achievements"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserViewModel {
    id?: number;
    fullName?: string;
    profilePic?: string;
    points?: number;
    balance?: number;
    rewards?: UserRewardDto[];
    achievements?: UserAchievementDto[];
}

export class UserRewardDto implements IUserRewardDto {
    rewardName?: string;
    rewardCost?: number;
    awarded?: boolean;
    awardedAt?: Date | undefined;

    constructor(data?: IUserRewardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rewardName = _data["rewardName"];
            this.rewardCost = _data["rewardCost"];
            this.awarded = _data["awarded"];
            this.awardedAt = _data["awardedAt"] ? new Date(_data["awardedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRewardDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRewardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rewardName"] = this.rewardName;
        data["rewardCost"] = this.rewardCost;
        data["awarded"] = this.awarded;
        data["awardedAt"] = this.awardedAt ? this.awardedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserRewardDto {
    rewardName?: string;
    rewardCost?: number;
    awarded?: boolean;
    awardedAt?: Date | undefined;
}

export class UserAchievementDto implements IUserAchievementDto {
    achievementId?: number;
    achievementName?: string;
    achievementValue?: number;
    complete?: boolean;
    achievementType?: AchievementType;
    achievementIcon?: Icons;
    achievementIconIsBranded?: boolean;
    awardedAt?: Date | undefined;

    constructor(data?: IUserAchievementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.achievementId = _data["achievementId"];
            this.achievementName = _data["achievementName"];
            this.achievementValue = _data["achievementValue"];
            this.complete = _data["complete"];
            this.achievementType = _data["achievementType"];
            this.achievementIcon = _data["achievementIcon"];
            this.achievementIconIsBranded = _data["achievementIconIsBranded"];
            this.awardedAt = _data["awardedAt"] ? new Date(_data["awardedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserAchievementDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAchievementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["achievementId"] = this.achievementId;
        data["achievementName"] = this.achievementName;
        data["achievementValue"] = this.achievementValue;
        data["complete"] = this.complete;
        data["achievementType"] = this.achievementType;
        data["achievementIcon"] = this.achievementIcon;
        data["achievementIconIsBranded"] = this.achievementIconIsBranded;
        data["awardedAt"] = this.awardedAt ? this.awardedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserAchievementDto {
    achievementId?: number;
    achievementName?: string;
    achievementValue?: number;
    complete?: boolean;
    achievementType?: AchievementType;
    achievementIcon?: Icons;
    achievementIconIsBranded?: boolean;
    awardedAt?: Date | undefined;
}

export class UserAchievementsViewModel implements IUserAchievementsViewModel {
    userId?: number;
    points?: number;
    userAchievements?: UserAchievementDto[];

    constructor(data?: IUserAchievementsViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.points = _data["points"];
            if (Array.isArray(_data["userAchievements"])) {
                this.userAchievements = [] as any;
                for (let item of _data["userAchievements"])
                    this.userAchievements!.push(UserAchievementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserAchievementsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserAchievementsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["points"] = this.points;
        if (Array.isArray(this.userAchievements)) {
            data["userAchievements"] = [];
            for (let item of this.userAchievements)
                data["userAchievements"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserAchievementsViewModel {
    userId?: number;
    points?: number;
    userAchievements?: UserAchievementDto[];
}

export class UserRewardsViewModel implements IUserRewardsViewModel {
    userId?: number;
    userRewards?: UserRewardDto[];

    constructor(data?: IUserRewardsViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["userRewards"])) {
                this.userRewards = [] as any;
                for (let item of _data["userRewards"])
                    this.userRewards!.push(UserRewardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRewardsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserRewardsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.userRewards)) {
            data["userRewards"] = [];
            for (let item of this.userRewards)
                data["userRewards"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserRewardsViewModel {
    userId?: number;
    userRewards?: UserRewardDto[];
}

export class ProfilePicResponseDto implements IProfilePicResponseDto {
    picUrl?: string;
    achievementAwarded?: boolean;

    constructor(data?: IProfilePicResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.picUrl = _data["picUrl"];
            this.achievementAwarded = _data["achievementAwarded"];
        }
    }

    static fromJS(data: any): ProfilePicResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePicResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["picUrl"] = this.picUrl;
        data["achievementAwarded"] = this.achievementAwarded;
        return data;
    }
}

export interface IProfilePicResponseDto {
    picUrl?: string;
    achievementAwarded?: boolean;
}

export class UpsertUserSocialMediaId implements IUpsertUserSocialMediaId {
    achievementId?: number;
    socialMediaPlatformUserId?: string;

    constructor(data?: IUpsertUserSocialMediaId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.achievementId = _data["achievementId"];
            this.socialMediaPlatformUserId = _data["socialMediaPlatformUserId"];
        }
    }

    static fromJS(data: any): UpsertUserSocialMediaId {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertUserSocialMediaId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["achievementId"] = this.achievementId;
        data["socialMediaPlatformUserId"] = this.socialMediaPlatformUserId;
        return data;
    }
}

export interface IUpsertUserSocialMediaId {
    achievementId?: number;
    socialMediaPlatformUserId?: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}